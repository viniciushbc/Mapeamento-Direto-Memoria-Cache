# -*- coding: utf-8 -*-
"""Memoria Cache - Mapeamento Direto.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MvemLwNnnX0l-9jxyExF14yKk7zdsQ1n
"""

import random

class Cache:

  # Construtor da cache
  def __init__(self, tamanhoCache, tamanhoRam):
    self.tamanhoCache = tamanhoCache
    self.tamanhoRam = tamanhoRam
    self.ram = {}
    self.cache = {}
    self.popularRam()
    self.inicializarCache()

  # A função que popula a RAM, com dicionario composto 'linha''valor'
  # A ideia é armazenar a LINHA DA CACHE respectiva à qual aquele endereço representa.
  # Ou seja, o dicionario RAM e CACHE possuem 3 atributos: Endereço na memória, Linha da posição na cache e Valor

  def popularRam(self):
    for i in range(self.tamanhoRam):
        self.ram[i] = {
            'linha': i%self.tamanhoCache,
            'valor': random.randint(0,100)
      }

  def inicializarCache(self):
    for i in range(self.tamanhoCache):
        self.cache[i] = {
            'endereco': None,
            'valor': None
        }

  def buscarEndereco(self, endereco, valorNovo):
    blocoRam = int(endereco/self.tamanhoCache)
    linha = endereco%self.tamanhoCache

    print("---------------------------------")
    print(f"Buscando endereço: {endereco}")

    dadoCache = self.cache[linha]


    # Verficar se a a linha que eu procuro está vazia, então, carregar a linha com o endereço
    if dadoCache['endereco'] is None:
      print("RESULTADO: Linha da cache vazia!")
      self.cache[linha]['endereco'] = endereco
      self.cache[linha]['valor'] = valorNovo
      self.ram[endereco]['valor'] = valorNovo

    # CACHE HIT - Subsituo o valor anitgo com o valorNovo no endereço da RAM e da Cache
    elif dadoCache['endereco'] == endereco:
      print(f"RESULTADO: Cache hit na linha {linha}!")
      self.ram[endereco]['valor'] = valorNovo
      self.cache[linha]['valor'] = valorNovo

    # CACHE MISS - Substitui o valor
    else:
        print(f"RESULTADO: Cache miss - Substituindo com novo endereço")
        enderecoAntigo = dadoCache['endereco']

        self.ram[enderecoAntigo]['valor'] = self.cache[linha]['valor']
        self.cache[linha]['endereco'] = endereco
        self.cache[linha]['valor'] = valorNovo
        self.ram[endereco]['valor'] = valorNovo
    print("---------------------------------")

  # Print da memória RAM
  def printRam(self):
      print("\n           RAM")
      print("Endereço | Linha | Valor")
      print("------------------------")
      for endereco, dados in self.ram.items():
          linha = dados['linha']
          valor = dados['valor']
          print(f"{endereco:^8} | {linha:^5} | {valor:^5}")


  # Print da memória Cache
  def printCache(self):
    print("\n           Cache")
    print("Linha | Endereço | Valor")
    print("------------------------")
    for linha, dados in self.cache.items():
        endereco = dados['endereco'] if dados['endereco'] is not None else "-"
        valor = dados['valor'] if dados['valor'] is not None else "-"
        print(f"{linha:^5} | {endereco:^8} | {valor:^5}")


cache = Cache(3, 18)

cache.printRam()
cache.printCache()

cache.buscarEndereco(1, 10)
cache.printCache()

cache.printRam()

cache.buscarEndereco(4, 16)
cache.printCache()

cache.printRam()

cache.buscarEndereco(6, 19)
cache.printCache()

cache.printRam()

cache.buscarEndereco(8, 99)
cache.printCache()

cache.printRam()


cache.buscarEndereco(8, 12)
cache.printCache()

cache.printRam()